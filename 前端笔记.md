# 1. 开发环境

​	使用**Visual Studio Code**文本编辑器。

​	安装插件如下：

| 插件名                        | 描述     |
| ----------------------------- | -------- |
| Chinese (Simplified) Language | 汉化包   |
| Ayu                           | 主题     |
| Live Server                   | 渲染页面 |

​	在常用设置中打开Auto Save。

​	使用**Zeal**软件下载API文档便于本地使用。

# 2. HTML

## 2.1. html基本结构

```html
<!--声明此文档要用HTML5的标准解析   -->
<!doctype html>
<!--语言是英语 chrome的翻译根据这个来提示是否翻译 zh是中文-->
<html lang="en">
<head>
    <!--<meta> 标签永远位于 head 元素内部。 -->
    <meta charset="utf-8"/>
    <!--提供网页关键字 供搜索引擎用 -->
	<meta name="keywords" content="关键字,学习,html"/>
	<meta name="description" content="描述"/>
    <!--2秒后跳转到百度 -->
    <meta http-equiv="refresh" content="2;URL=http://www.baidu.com">
    <title></title>
</head>
<body>    
</body>
</html>
```

```html

<!doctype html>
<!--设置文件字符集编码 -->
<meta charset="utf-8"/>

```

## 2.2 实体

| 显示结果 | 描述   | 实体名称 |
| -------- | ------ | -------- |
|          | 空格   | &nbsp;   |
| <        | 小于号 | &lt;     |
| >        | 大于号 | &gt;     |
| ©        | 版权   | &copy;   |
| &        | 和号   | &amp;    |

## 2.3 语义化标签

块元素

```html
<h1></h1>
<h6></h6>
<p></p>

```

行内元素

```html
<em></em>
<span></span>无语义
```

注意：网页中一般通过块元素来对页面进行布局。行内元素主要用来包裹文字。一般情况下会在块元素中放行内元素，而不会在行内元素中放块元素。块元素中基本上什么都能放，p标签中不能放任何块元素。浏览器解析网页的时候，有容错机制。

**ctrl + enter 光标换行**。

## 2.4 布局标签

```html
<header></header>表示网页的头部
<main></main>表示网页的主体部分(一个页面中只会有一个目标main)
<nav></nav>表示网页的导航
<aside></aside>侧边栏
<article></article>表示一个独立的文章
<section></section>表示一个独立的区块，上边的标签都不能表示的时候用section 
<div></div>没有语义，就用来表示一个区块。 
```

## 2.5 列表

有序列表

```html
<ul>
    <li></li>
</ul>
```

无序列表

```html
<ol>
    <li></li>
</ol>
```

定义列表

```html
<dl>
    <dt></dt>
    <dd></dd>
</dl>
```

可列表嵌套

## 2.6 超链接

**alt + shift + 方向下键即可复制一行**

href可以是一个外部网址，也可以是一个内部html，也能跳到当前页面的某个位置

```html
<a href="http://www.baidu.com">百度</a>超链接是一个行内元素，但是在a标签是可以嵌套除它之外的所有标签。
```

a标签中有一个**target**属性

target取值

| 取值   | 描述                            |
| ------ | ------------------------------- |
| _self  | 默认值   在当前页面中打开超链接 |
| _blank | 在一个新的页面打开超链接        |

```html
<a href="#">回到顶部</a>
<a href="#where">回到id为where的标签地方</a>
<a href="javascript:;">此时点击这个超链接什么也不会发生</a>
```

## 2.7 图片标签

scr是图片路径，alt是图片的描述，一般用于搜索引擎。

```html
<img src="" alt="" width="" height=""/>
<!--宽高只设置一个   图片会等比例绽放 -->
<!--一般情况在pc端不建议改图片大小，需要多大图片就裁多大 -->
```

图片格式：

- jpeg(jpg)  - 支持的颜色比较丰富，不支持透明效果，不支持动图
- gif -支持颜色比较少，支持简单透明，支持动图，颜色单一
- png - 支持颜色丰富，支持复杂透明，不支持动图，颜色单一的图片，动图。
- webp - 这种格式是谷歌新推出的专门用来表示网页中的图片。它具备其它图片格式的所有优点，而且文件还特别小。就是兼容性不好。
- base64 -将图片用base64编码。将图片转换到base64。图片要和网页一同加载时用。

## 2.8 音视频

​	audio标签用来向页面中引入一个外部的音频文件，音视频文件引入时，默认情况下不允许用户自己控制播放停止。

​	属性：controls：是否允许用户控制播放

​				autoplay:音频文件是否自动播放

​				loop：音乐循环播放

```html
<audio src="" controls autoplay loop></audio>
```

```html
<!-- 除了通过src指定外部文件的路径以外，还可以通过source来指定文件-->
<audio control>
	对不起，您的浏览器不支持播放音频，请升级浏览器！
    <source src="">
    <source src="">
    <source src="">
    <!--这个embed是兼容ie的 -->
    <embed src="" type="audio/mp3" width="" height="">
</audio>
```

​	video标签来向网页引入一个视频，使用方式和audio一样

```html
<video control>
    <source src="">
</video>
```

# 3. CSS

## 3.1 样式

```html
<!-- 
	网页分成三个部分：
	结构(HTML)，
	表现(CSS),
	行为(JavaScript)
-->
<!-- 第一种方式：在标签内部通过style属性元素的样式-->
<p style="color:red;font-size:60px;">
    清明时节雨纷纷，路上行人欲断魂。
</p>
<!--第二种方式：也可以用style在页面内定义 -->
<style>
    p{
        color: red;
        font-size: 50px;
    }
</style>
<!--第三种方式：引入外部css样式 将样式编写到外部的css文件中，可以使用到浏览器中的缓存机制。从而加快网页的加载速度，提高用户体验-->
<link rel="stylesheet" href="">
```

## 3.2 Type selectors

​	The CSS **type selector** matches elements by node name. In other words, it selects all elements of the given type within a document.标签选择器。

```css
/* All <a> elements. use tag name*/
a {
    color: red;
}
span {
    background-color: skyblue;
}
```

## 3.3 Class selectors

​	The CSS class selector matches elements based on the contents of their class attribute.

```css
.red {
    color: #f33;
}

.yellow-bg {
    background: #ffa;
}

.fancy {
    font-weight: bold;
    text-shadow: 4px 4px 3px #77f;
}
```

```html
<p class="red">This paragraph has red text.</p>
<p class="red yellow-bg">This paragraph has red text and a yellow background.</p>
<p class="red fancy">This paragraph has red text and "fancy" styling.</p>
<p>This is just a regular paragraph.</p>
```

## 3.4 ID selectors

​	The CSS ID selector matches an element based on the value of its id attribute. In order for the element to be selected, its id attribute must match exactly the value given in the selector.id值在同一个页面中不能重复。

```css
#identified {
    background-color: skyblue;
}
```

```html
<div id="identified">
    This div has a special ID on it!
</div>
```

## 3.5 Attribute selectors

​	The CSS attribute selector matches elements based on the presence or value of a given attribute.

- [attr]

  Represents elements with an attribute name of *attr*.

  表示属性名称为attr的元素。

- [attr=value]

  Represents elements with an attribute name of *attr* whose value is exactly *value*.

  表示属性名称为attr的元素，其值恰好是value。

- [attr~=value]

  Represents elements with an attribute name of *attr* whose value is a whitespace-separated list of words, one of which is exactly *value*.

  表示属性名称为attr的元素，其值是用空格分隔的单词列表，其中之一就是值。

  ```css
  p[class~="value2"] {
      color: red;
  }
  ```

  ```html
  <p class="value1 value2">
      test
  </p>
  ```

  > 感觉这个属性选择器的匹配机制没有多大用。

- [attr|=value]

  Represents elements with an attribute name of attr whose value can be exactly value or can begin with value immediately followed by a hyphen, - (U+002D). It is often used for language subcode matches.

  表示属性名称为attr的元素，其值可以完全是value或可以以value开头，后跟连字符-（U + 002D）。它通常用于语言子代码匹配。

  ```css
  /* 匹配href是example或href是以example开头后跟-的标签*/
  a[href|="example"] {
              background-color: slateblue;
          }
  ```

  ```html
  <a href="example">example</a>
  <a href="example-text">example-test</a>
  ```

- [attr^=value]

  Represents elements with an attribute name of *attr* whose value is prefixed (preceded) by *value*.

  表示属性名称为attr的元素，其值以值为前缀（在前面）。

- [attr$=value]

  Represents elements with an attribute name of *attr* whose value is suffixed (followed) by *value*.

  表示属性名称为attr的元素，其值以值后缀（后跟）。

  > **提示：**^和$也是正则表达式的开始标志和结束标志

- [attr*=value]

  Represents elements with an attribute name of *attr* whose value contains at least one occurrence of *value* within the string.

  表示属性名称为attr的元素，其值包含至少一个在字符串中出现的值。

  > 提示：一个属性可以有多个值，至少要有一个值中包含所匹配的值

- [attr operator value i]

  Adding an `i` (or `I`) before the closing bracket causes the value to be compared case-insensitively (for characters within the ASCII range).

  在右括号之前添加一个i（或I）将导致不区分大小写地比较该值（对于ASCII范围内的字符）。

  ```css
  a[href^='eXaM' i]{
      /*不区分大小写进行匹配*/
      color: red;
  }
  ```

  

- [attr operator value s]

  Adding an `s` (or `S`) before the closing bracket causes the value to be compared case-sensitively (for characters within the ASCII range).

  在右括号前添加s（或S）会导致区分大小写地比较该值（对于ASCII范围内的字符）。

  > 这个在s没有任何必要   加上s会报错

## 3.6 Grouping selectors

​	The CSS **selector list** (`,`) selects all the matching nodes.

```css
/* Selects all matching elements */
span,div {
  border: red 2px solid;
}
```

## 3.7 Combinators

​	组合选择器

- ​	Adjacent sibling combinator 相邻的同级组合器    A + B

  ​	A和B必须有同一个父节点；

  ​	B必须紧随A后；

  ```css
  /*  li:first-of-type就指的第一个li*/
  /*  再带一个  + li就相当于是选择的是第二个li*/
  li:first-of-type + li {
      color: red;
  }
  ```

  ```html
  <!--那么就是第二个li的颜色为红色 -->
  <ul>
      <li>One</li>
      <li>Two</li>
      <li>Three</li>
  </ul>
  ```

  

- General sibling combinator 通用同级组合器  A ~ B

  A和B必须有同一个父节点；

  B必须在A之后；

  ```css
  p ~ span {
    color: red;
  }
  ```

  ```html
  <span>This is not red.</span>
  <p>Here is a paragraph.</p>
  <code>Here is some code.</code>
  <span>And here is a red span!</span>
  <code>More code...</code>
  <span>And this is a red span!</span>
  ```

  

- Child combinator 子组合器 A > B

  Specifies that the element selected by `B` is the **direct** child of the element selected by `A`.

  ```css
  span {
    background-color: white;
  }
  
  div > span {
    background-color: DodgerBlue;
  }
  ```

  ```html
  <div>
    <span>Span #1, in the div.
      <span>Span #2, in the span that's in the div.</span>
    </span>
  </div>
  <span>Span #3, not in the div at all.</span>
  ```

- Descendant combinator A B

  Specifies that the element selected by `B` is a descendant of the element selected by `A`, but is not necessarily a direct child.

  ```css
  li {
    list-style-type: disc;
  }
  
  li li {
    list-style-type: circle;
  }
  ```

  ```html
  <ul>
    <li>
      <div>Item 1</div>
      <ul>
        <li>Subitem A</li>
        <li>Subitem B</li>
      </ul>
    </li>
    <li>
      <div>Item 2</div>
      <ul>
        <li>Subitem A</li>
        <li>Subitem B</li>
      </ul>
    </li>
  </ul>
  ```


## 3.8 Pseudo-classes伪类

​	Specifies a special state of the selected emement(s)

​	伪类是用来描述一个元素的特殊状态的。以一个：开头。

- :first-child  第一个子元素

- :last-child 最后一个子元素

- :nth-child() 选中第n个子元素

  特殊值：

  - n 第n个，n的范围是0到正无穷
  - 2n 或even  表示选中偶数位的元素
  - 2n-1 或odd 表示选中奇数位的元素

  > 以上这些伪类都是根据所有的子元素进行排序的

- :first-of-type

- :last-of-type

- nth-of-type

> 以上-of-type这几个伪类的功能和-child类似，不同点在于-of-type是同类中排序。-child不是同类也放一起排序。

- :link 用来表示没有访问过的链接
- :visited 用来表示访问过的链接，由于隐私的原因，所以visited这个伪类只能修改链接的颜色
- :hover 鼠标移入的状态
- :active 用来表示鼠标点击

## 3.9 Pseudo-elements伪元素

​	A CSS **pseudo-element** is a keyword added to a selector that lets you style a specific part of the selected element(s).

- ::first-letter  首字母
- ::first-line 首行
- ::selection  选中文本时触发什么属性
- ::before  在之前
- ::after 在之后

## 中途加油站

### 一、样式的继承

​	样式的继承，我们为一个元素设置的样式同时也会应用到它的后代元素上。看一个属性是否会继承，去Zeal中看属性的Inheritance

### 二、选择器的权重

​	样式的冲突 -当我们通过不同的选择器，选中相同的元素，并且为相同的样式设置不同的值时，此时就发生了样式的冲突。发生冲突样式冲突时，应用哪个样式由选择器的权重(优先级)决定。 

组合选择器的优先级是相加计算再比较。(分组选择器是单独计算的)

选择器的权重：

内联样式 > id选择器 > 类和伪类选择器 > 元素选择器 > 通配选择器 > 继承的样式

可是在某一个样式的后面添加  **!important** 来提高样式的优先级。

### 三、单位

- 像素(px)

- 百分比

- em(是相对于元素的字体大小来计算的，1em = 1font-size  ,em会根据字体大小的改变而改变)

- rem（相对于根元素[html]的字体大小来计算的）

- 颜色单位

  - 直接用颜色名

  - 使用RGB值（光的三元色），每个颜色取值范围是0~255，rgb(255,0,0);

  - 使用RGBA，带透明效果。a的取值范围[0，1]，0是完全透明，1是完全不透明。

  - 十六进制  以#红色绿色蓝色，颜色浓度00-ff，如果颜色两位重复可以简写。#aabbcc等同于#abc

  - HSLA值

  - HSL值

    H 色相  取值范围[0,360]

    S 饱和度 取值范围[0%,100%]

    L 亮度 ,颜色的亮度 取值范围[0%,100%]

# 4. layout 布局

​	文档流(normal flow)

​		-网页是一个多层的结构，一层摞一层

​		-通过css可以分别为每一层来设置样式

​		-作为用户来讲只能看到最顶上的一层

​		-这些层中，最底层称为文档流，文档流是网页的基础，我们所创建的元素默认都是文档流中进行排列。

​		-对于我们来说，元素主要有两个状态

​			在文档流中

​			不在文档流中(脱离了文档流)

​		-元素在文档流中有什么特点：

​			**-块元素**

​				-块元素会在页面中独占一行，在只进行宽高设置的前提下，仍然是独占一行。

​				-默认宽度是父元素的全部(会把父元素撑满)

​				-默认高度是被内容撑开(子元素)

​			**-行内元素**

​				-行内元素不会独占页面的一行，只占自身的大小

​				-行内元素在页面中自左向右水平排列。如果一行之中不能容纳下所有的行内元素，则元素会换到第二行继续自左向右排列(书写习惯)

## 4.2 Box model盒模型

​	css将页面中的所有元素都设置为了一个矩形的盒子了，将元素设置为矩形的盒子后，对页面的布局就变成了将不同例子摆放到不同的位置。每一个盒子都由以下几个部分组成：

- content（内容区）

```css
.box1{
    /* width和height设置的是内容区的宽度和高度*/
    width: 200px;
    heigth: 200px;
}
```

- padding（内边距）

​	内边距是内容区和边框之间的距离，padding-top  padding-right padding-bottom padding-left, 内边距的设置会影响到盒子大小，背景颜色会延伸到内边距上。一个盒子的可见大小，由内容区、内边距和边框共同决定，所以在计算例子大小时，需要将这三个区域加到一起

```css
.outer {
    width: 200px;
    height: 200px;
    border:10px pink solid;
    background-color: skyblue; 
    /*padding区会被background-color填充*/
    padding:20px;
}

.inner{
    /* 填充outerdiv的内容区*/
    width: 100%;
    height: 100%;
    background-color: springgreen;
}

```

```html
<div class="outer">
    <!-- inner这个div是在内容区创建的-->
    <div class="inner"></div>
</div>
```



- border（边框）

```css
/*border-width值的情况 
	四个值：上 右 下 左
	三个值：上 左右 下
	两个值：上下 左右
	一个值：上下左右
除了border-width还有一组 border-xxx-width
xxx可以是  top rigth bottom left用来单独指定某一个边的宽度
border-color同理，也有默认值。
border-style：solid 表示实线   dotted点状虚线   dashed虚线 double 双线   none 无边框
*/
.box{
    /* 边框属于盒子边缘，边框里边属于盒子内部，出了边框都是盒子的外部，边框的大小会影响到整个盒子的大小,border-width有默认值*/
    border-width: 10px;
    border-color: red;
    border-style: solid;
    /*也可以用 border: 10px red solid;来设置这三个属性*/
}
```



- margin（外边距）

​	外边距不会影响盒子的可见框的大小，但是会影响盒子的位置，同样有四个方向的外边距。左上移自己，右下移别人。

​	-  margin-top 正值向下走 负值反着走

​	- margin-right 是移动右边的盒子，默认情况下设置margin-rigth是没有用的

​	- margin-bottom 是移动下方的盒子

 	-margin-left 正值向右移动 负值反着走

## 4.3 水平方向布局

​	一个元素在父元素中，那么水平布局必须满足以下的等式。

子元素的（margin-left + border-left + padding-left + width + padding-rigth + border-right + magin-right） = 其父元素内容区的宽度（必须满足）。

​	以上等式必须满足，如果相加等式不成立，则称为过渡约束，则等式会自动调整。七个值中只有width（默认值为auto）、magin-left（默认值为0 ）、magin-right（默认值为0）可以设置为auto.

​	调整情况:

​	-如果三个值中没有auto，那么浏览器会自动调整margin-right值以使等式成立。

​	-如果三个值中的某一个值为auto，那么会自动调整auto对应的属性以例等式成立。

​	-如果将一个宽度和一个外边距设置为auto，或三个都是auto，那么只有width生效。

​	-如果两个magin-left和magin-right为auto，则会将外边距设置成相同的值。所以我们经常利用这个特点来使一个元素在其父元素中水平居中。

## 4.3 垂直方向布局

​	子元素是在父元素的内容区中排列的，如果子元素的大小超过了父元素，则子元素会从父元素中溢出，使用overflow属性来设置父元素如何处理溢出的子元素；

| overflow可取值 | 描述                             |
| -------------- | -------------------------------- |
| visible        | 默认值，溢出部分在父元素外部显示 |
| hidden         | 隐藏溢出部分                     |
| scoll          | 生成滚动条                       |
| auto           | 根据情况自动处理溢出部分         |

overflow-x和overflow-y类似

## 4.4外边距的折叠

​	垂直外边距的折叠，相邻的垂直方向外边距会发生重叠现象

​		-兄弟元素间的相邻垂直外边距会取两者之间的较大者

```css
	.box1, .box2{
        width: 200px;
        height: 200px;
        font-size: 100px;
    }
    .box1{
        background-color: slateblue;
    }
    .box2{
        background-color: springgreen;
    }
```

```html
<div class="box1"></div>
<div class="box2"></div>
```

​	-父子元素

​		-父子元间相邻外边距，子元素的会传递给父元素(上外边距)

​		-父子外边距的折叠会影响到页面的布局，必须要进行处理(可以在中间添加border来隔开，但是不推荐这么使用)

## 4.5 行内元素的盒模型

​	-行内元素不支持设置width和height，（内容自动撑起行内元素的宽高）

​	-行内元素可以设置padding、border、margin，但是垂直方向不会以影响页面的布局

> **display** 用来设置元素显示的类型
>
> 可选值   inline将元素设置为行内元素；block将元素设置为块元素；inline-block将元素设置为行内块元素；table将元素设置为一个表格；none元素不在页面中显示且不占页面位置。
>
> **visibility** 用来设置元素的显示状态
>
> 可选值 visible 默认值，元素在页面中正常显示；hidden元素在页面中隐藏不显示，但是依然占据页面的位置。

## 4.6 浏览器的默认样式

​	通常情况下浏览器会为元素设置默认样式，这样会影响到布局，所以要去除浏览器的默认样式。

​	可以下载reset.css去除浏览器的默认样式，也可以下载normalize.css对

## 4.7 盒子的大小

​	**盒子的可见框大小由内容区和内边距和边框决定。**

​	box-sizing用来设置盒子尺寸的计算方式(设置width和height的作用)。

​	可选值：

1. **content-box**  默认值，即宽度和高度表示的是内容区的大小，gives you the default CSS box-sizing behavior. If you set an element's width to 100 pixels, then the element's content box will be 100 pixels wide, and the width of any border or padding will be added to the final rendered width, making the element wider than 100px.

2. **border-box**  设置的宽度和高度表示盒子的可见框的大小，tells the browser to account for any border and padding in the values you specify for an element's width and height. If you set an element's width to 100 pixels, that 100 pixels will include any border or padding you added, and the content box will shrink to absorb that extra width. This typically makes it much easier to size elements.

## 4.8 轮廓和圆角

​	**outline**用来设置元素的轮廓线，用法和border一模一样，轮廓和边框不同的点在于，轮廓不会影响到可见框的大小

```css
.outline{
	outline: 1px red solid;
}
```

​	**box-shadow**用来设置元素的阴影效果，阴影不会影响页面布局

```css
/*
	第一个参数是水平偏移量
	第二个参数是垂直偏移量
	第三个参数是模糊半径,值越大越模糊
	第四个参数是颜色
*/
.box-shadow{
    box-shadow: 10px 20px 30px rgba(0,0,0,.5);
}
```

​	**border-radius**用来设置圆角，设置的值是圆的半径。一共有四个圆角，border-top-left-radius，border-top-right-radius，border-bottom-right-radius，border-bottom-left。圆角也可以设置成椭圆的

```css
border-radius: 20px;
border-radius: 20px/30px;//这个是椭圆的一个角
```

# 5. 浮动

​	通过浮动可以使一个元素向其父元素的左侧或右侧移动

​	使用float属性来设置元素的移动

​	可选值

  - none  默认值  元素不浮动

  - left 元素向左浮动

  - right 元素向右浮动

    注意：元素设置浮动以后，水平布局的等式就不需要强制成立

    ，并且元素此时已经脱离了文档流，不再占用文档的位置，所以元素下边的还在文档流中的元素会自动向上移动

    **浮动的特点**

    1. 浮动的元素会完全脱离文档流，不再占据文档流的位置

    2. 设置浮动以后元素会向父元素的左侧或右侧移动，多个元素在父元素中浮动时，多个子元素宽度和大于了父元素的宽度，部分子元素会下移。

    3. 浮动元素默认不会从父元素中移出

    4. 浮动的元素向左或向右移动时，不会超过它前边的其它浮动元素

    5. 如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移

    6. 浮动元素不会超过它上边的浮动的兄弟元素，最多最多就是它一样的高度

    简单总结：浮动目前来讲它的主要作用就是让页面中的元素可以水平排列，浮动的元素不会覆盖住文字，文字会自动环绕在浮动元素的周围。所以我们可以利用浮动来设置文字的环绕图片效果

    > 元素设置浮动以后，将会从文档流中脱离，脱离文档流的特点：
    >
    > 块元素：
    >
    > - 块元素不在独占页面的一行，
    >
    > - 脱离文档流以后，块元素在没设置宽高时，宽度和高度默认都被内容撑开。
    >
    > 行内元素：
    >
    > - 行内元素脱离文档流以后会变成块元素，特点和块元素一样。
    >
    > **脱离文档流以后，不需要再区分块和行内了**

## 5.1 高度塌陷

​	高度塌陷问题：在浮动布局中，父元素的高度是被子元素撑起来的，当子元素浮动后，会脱离文档流，子元素从文档流中脱离将会导致父元素的高度塌陷。父元素的高度丢失以后，其下的元素会自动上移，导致页面的布局混乱，所以高度塌陷是浮动中比较觉的一个问题，这个问题我们必须进行处理。

​	可以通过开启BFC（Block Formatting Content）块级格式化环境，BFC是一个css的一个隐含属性，可以为一个元素开启BFC。开户BFC该元素会变成一个独立的布局区域。

元素开启BFC后的特点：

- 开启BFC的元素不会被浮动元素所覆盖

- 开启BFC的元素子元素和父元素外边距不会重叠

- 开启BFC的元素可以包含浮动的子元素

  可以通过一些特殊方式：详情请看Zeal中的block formatting content,

  overflow: hidden;可以开启BFC；

  > 可以通过clear来清除浮动
  >
  > 可选值：
  >
  > - left  清除左侧浮动元素对当前元素的影响
  > - right 清除右侧浮动元素对当前元素的影响
  >
  > 原理：设置清除浮动后，浏览器会自动为元素添加一个上外边距，以使其位置不受其他元素的影响，但是开发都工具不会有所显示。
  >
  > - both 清除受到浮动影响最大那一侧

**用::after来清除浮动**

```css
.box1::after{
    clear:both;
    display:block;
}
```

```html
<!--.box1::after指的是box1的最末尾 可以理解为内容区的底部 -->
<div class="box1">
    <div class="inner">
        
    </div>
</div>
```

用多功能的clearfix，这个样式可以同时解决高度塌陷和外边距重叠的问题。

```css
.clearfix::befor,.clearfix::after{
    content: '';
    block:table;
    clear:both;
}
```

```html
<div class="clearfix">
    <div class="inner">
        
    </div>
</div>
```



# 6. position定位

​	定位是一种更加高级的布局手段，通过定位可以把元素摆放到页面的任意位置

| position可选值 | 描述                             |
| -------------- | -------------------------------- |
| static         | 默认值，元素是静止的没有开启定位 |
| relative       | 开启元素的相对定位               |
| absolute       | 开启元素的绝对定位               |
| fixed          | 开启元素的固定定位               |
| sticky         | 开启元素的粘滞定位               |

- **relative**相对定位：

  当元素的position属性设置为relative时则开启了元素的相对定位，

  **相对定位的特点**

  1. 元素开启相对定位以后，如果不设置偏移量元素不会发生任何的变化。
  2. 相对定位是参照于元素在文档流中的位置进行定位的

  ```css
  /* 这样就可以知道参照点了*/
  .test{
      position: relative;
      top: 0;
      left: 0;
  }
  ```

  1. 相对定位会提升元素的层级。
2. 相对定位不会使元素脱离文档流。
  3. 相对定位不会改变元素的性质，块还是块，行内不是行内。

  - 偏移量(offset)
  
    当元素开启定位以后，可以通过偏移量来设置元素的位置。

    - top  定位元素和定位位置上边的距离
    
    - bottom 定位元素和定位位置下边的距离，定位元素垂直方向的位置由top和bottom两个属性来决定
    
    - left
    
    - right
- **absolute**绝对定位

  当元素的position属性的值设置为absolue时，则开启了绝对定位

  绝对定位的特点：

  1. 开启绝对定位后，（在没有开启浮动的情况下）如果不设置偏移量，元素的位置不会发生变化

  2. 开启绝对定位后，元素会脱离文档流。

  3. 绝对定位会改变元素的性质，行内变块，块的宽高被内容撑开

  4. 绝对定位会提升元素一个层级

  5. 绝对定位元素是相对于其包含块进行定位的

     包含块(containing block)

     - 正常情况下包含块就是离当前元素最近的祖先**块**元素，是块元素。
     - 包含块就是离它最近的**开启了定位**的**祖先块元素**，如果所有的祖先元素都没有开启定位则根元素就是它的包含块(<html>是根元素，也叫初始包含块)

- **fixed**固定定位

  将元素的position设置为fixed则开启了元素的固定定位

  固定定位也是一种绝对定位，所以固定定位的大部分特点都和绝对定位一样

  唯一不一样的是固定定位永远参照的是浏览器的视口进行定位（**viewport**）

  固定定位的元素不会随网页的滚动条滚动

- **sticky**粘滞定位

  当元素的position设置为sticky时元素开启了粘滞定位

  粘滞定位和相对定位(relative)的特点基本一致

  不同的是粘滞定位可以在元素到达某个位置时将其固定

```css
/* */
.test{
    position: sticky;
	top: 10px;
}
```

## 6.1 绝对定位元素的布局

- 水平布局

  left + margin-left/right + border-left/right +padding-left/right + right = width

  当我们开启了绝对定位后：

  - **水平方向**的布局等式就需要添加left 和 right 两个值，此时规则和之前的一样只是多添加了两个值；

  如果9个值中没有auto，则自动调整right值以使等式满足，如果有auto，则自动调整auto的值以使等式满足

  可设置auto的值：margin   width   left  right 

  因为left 和 right  的默认值是 auto,所以如果不指定left和right，等式不满足时，会自动调整这两个值

  - **垂直方向**的布局的等式也必须要满足

    top + margin-top/bottom + border-top/bottom + padding-top/bottom + bottom = height

  ```css
  position: absolute;
  margin: auto;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  则会居中
  ```

  ## 6.2 元素层级

  对于开启了定位元素，可以通过z-index属性来指定元素的层级，z-index需要一个整数作为参数，值越大元素的层级越高，元素的层级越高越优先显示。

  ​	如果元素的层级是一样的，那么优先显示html中后写的元素，**祖先的元素的层级再高也不会盖住后代元素**

# 7.  字体和背景

​		字体相关的样式

- color 用来设置字体颜色

- font-size 相关的单位

  - em 相当于当前元素的一个font-size
  - rem 相当于根元素的一个font-size

- font-family 字体族(字体的格式)

  - serif   衬线字体
  - sans-serif 非衬线字体
  - monospace 等宽字体
    - 指定字体的类别，浏览器会自动使用该类别下的字体
  - font-family 可以同时指定多个字体，多个字体间使用逗号隔开，字体生效时优先使用第一个，第一个无法使用则使用第二个  以此类推

  ```css
  /*@font-face 可以将服务器中的字体直接提供给用户使用*/
  @font-face {
      font-family: 'myfont';
      /*服务器中字体的路径*/
      src: url('./font/');
  }
  ```

  **字体的简写**

  ```css
  /*font 可以设置字体的相关的所有属性，语法
  	font: 字体大小/行高  字体族
  	行高可以省略不写  如果不写  则使用的是默认值
  */
  font: 50px/2 Times, serif;
  ```

  **font-weight**字重  字体的加粗    可选值   normal    bold   

  **font-style**字体风格   可选值   normal    italic

  具体值  参考Zeal中的CSS

## 7.1 图标字体

​	图标字体(**iconfont**)

- 在网页中经常需要使用一些图标，可以通过图片来引入图标，但是图片大本身比较大，并且非常的不灵活，所以在使用图标时，我们还可以将图标直接设置为字体，然后通过**font-face**的形式来对字体进行引入，这样我们就可以通过使用字体的形式来使用图标了

- **fontawesome** 使用步骤

  1. 下载[fontawesome][https://fontawesome.com]

  2. 解压

  3. 将css和webfonts移动到项目中，css和webfonts要放在同一个目录下。

  4. 将all.css引入到网页中

  5. 使用图标字体。**一定要注意字体版权问题**

     - 直接通过类名来使用图标字体

     ```html
     <!-- 要么用fas打头   要么用fab打头-->
     class="fas fa-bell"
     class="fab fa-accessible-icon"
     ```

- 图标字体的其它用法

  - 通过伪元素来设置图标字体

    1. 找到要设置图标的元素通过::before或::after选中

    2. 在content中设置字体的编码，这个编码在Zeal中Font Awesome的右侧十六进制数，要加一个\在前面

    3. 设置字体的样式

       - fab

         font-family: 'Font Awesome 5 Brands';

       - fas

         font-family: 'Font Awesome 5 Free';

         font-weigth: 10px;

    ```css
    li::before{
        content: '\f1b0';
        font-family: 'Font Awesome 5 Free';
        font-weight: 10px;
        color: skyblue;
    }
    
    ```

    ```html
    <i class="fas fa-cat">
    </i>
    ```

    

  - 也可以通过实体的形式来设置图标字体

  ```html
  <!--class要么是fas 要么是fab  因为这两个是free的   &开始加一个#输入编号然后以分号结束-->
  <span class="fas">
  &#f1b0;
  </span>
  ```

- 阿里巴巴的矢量图标库的使用

  1. 将要用的图标**添加入库**
  2. 滚动页面到顶部，点击右上角的车子
  3. 添加到项目，如果没有项目则需要先创建一个新的项目
  4. 然后在导航栏中的图标管理下面的我的项目中查看，可以下载资源到本地
  5. 除了html都加入项目中，引入iconfont.css到页面则可以用了

  ```html
  <i class="iconfont">&#xe61c;</i>
  ```

## 7.2. 行高(line height)

​	**行高**指的是文字占有的实际高度，可以通过l**ine-height**来设置行高，行高可以直接指定一个大小（px或者em作为单位），也可以直接用一个整数来设置行高，如果是整数的话，行高将会是字体的指定的倍数，行高是针对的单行，行高经常还用来设置文字的行间距。

​	**行间距** = 行高(line-height) - 字体大小(font-size)

​	**字体框**就是字体存在的格子，设置font-size实际上就是在设置字体框的高度

经常将行高和高度设置为一样的值，使单行文字在一个元素中垂直居中。

```css
height: 20px;
line-height: 20px;
```

## 7.3 文本

​	**text-align** 文本的水平对齐

​		可选值  left   right   center    justify(两端对齐)

​	**vertical-align**文本垂直对齐

​		可选值  baseline  默认值， 基线对齐   top    bottom   middle

```css
p{
    border: 1px red solid;
}
img{
    vertical-align: 只要不是基线;
}
```

```html
<!-- 这样就可以达到图片下边和border重合的效果-->
<p>
    <img src="">
</p>
```

## 7.4 其它文本

​	**text-decoration** 设置文本修饰

​	可选值：

- none  无
- underline 下划线
- line-through 删除线
- over-line  上划线

**white-space** 设置网页如何处理空白

​	可选值

- normal 正常
- nowrap 不换行
- pre 保留空白

```css
white-space:nowrap;
overflow:hidden;
text-overflow:ellipsis;//多出来的内容以省略号形式显示
```

> **可多看Zeal中的文档。**

## 7.5 背景图

​	**background-image**设置背景图片

- 可以同时设置背景图片和背景色，这样背景颜色将在图片下面。
- 如果背景的图片小于元素，则背景图片会自动在元素中平铺将元素铺满。
- 如果背景的图片大于元素，将有一个部分背景无法完全显示。
- 如果背景图片和元素一样大，则会直接正常显示。

```css
background-image: url("路径"); 
```

​	**background-repeat** 用来设置背景图片的位置

​	可选值：

- repeat  默认值  背景会沿着x轴  y轴双方向重复
- repeat-x  沿着x轴方向重复
- repeat-y  沿着y轴方向重复
- no-repeat  背景图片不重复

```css
background-repeat: no-repeat;
```

​	**background-position** 用来设置背景图片的位置，通过top left right bottom center 几个表示方位的词来设置背景的位置,要用一个水平方位和一个垂直方位来定位，如果只写一个，那么另一个默认为center。也可以通过偏移量来设置背景图片的位置。

```css
background-position: center center;
background-position: 10px 20px;
```

​	**background-clip** 设置背景的范围

​	可选值

- border-box 默认值 背景会出现在边框的下边
- padding-box 背景不会出现在边框下面
- content-box 背景只会出现在内容区

​    **background-origin** 设置图片的偏移量计算原点

​	可选值

- padding-box 默认值，background-position从内边距开始计算
- content-box 背景图片的偏移哽从内容区处计算
- border-box 背景图片的变量从边框处开始计算

​    **backgroud-size** 设置背景图片大小，第一个值表示宽度，第二个值表示高度，如果只写一个，那么另一个默认为**auto**(沿相应方向绽放背景图像，以保持其固有比例)。也可以给**cover**(图片等比例缩放，将图片完整的样子放入元素中，可能出现图片未覆盖的地方，也可能图片只有一部分在元素中)，**contain**(在不拉伸图像的情况下尽可能缩放图像。如果图像的比例与元素不同，则会垂直或水平裁剪图像，以确保没有空白空间。)

​	**background-clip** 设置元素的背景是否在其边框(border box)，填充框(padding box)或内容框(content box)下延伸。

​	可选值：

- border-box  背景延伸到边框外边缘，背景在边框的下方。

- padding-box  背景延伸到填充的外部边缘。边框下方未绘制背景。

- content-box 背景只在内容区中绘制。

   **background-origin** 设置背景的原点

可选值：

- border-box 背景图相对于border box开始绘画
- padding-box 背景图相对于padding box开始绘画
- content-box 背景图相对于content box 开始绘画

> background-clip和background-origin的区别
>
> 先设置background-origin,绘画出背景，然后设置background-clip，进行裁剪。

**background-attachment** 背景图片是否跟随元素移动

可选值：

- scorll 默认值  背景图片会跟随元素移动，相对于viewport移动，viewport用background-position来设置。
- fixed 背景会固定在页面中，不会随元素移动

> 简写的时候没有要求，但是
>
> background-size必须在background-position后面，并且用/隔开
>
> ```css
> background-position/background-size
> ```
>
> background-clip必须在background-origin后面
>
> ```css
> border-box padding-box
> ```

> 关于背景图：图片属性网页中的外部资源，外部资源都需要浏览器单独改善请求加载。浏览器加载外部资源时是按需加载，用则加载，不用则不加载。
>
> # Implementing image sprites in CSS(Zeal)，用雪碧图来减少HTTP请求的数量。
>
> 雪碧图的特点：一次性将多个图片加载进页面，降低请求次数，提升用户体验。

## 7.6 渐变

​	通过渐变可以设置一些复杂的背景颜色，可以实现从一个颜色向其他颜色过渡的效果，**渐变是图片，需要通过background-image**来设置

- **linear-gradient()** 线性渐变，颜色沿着一条直线发生变化,

  deg是度数，turn是圈数，颜色可以给多个值。

```css
background-image:linear-gradient(red,blue);
background-image:linear-gradient(to left,red,blue);
background-image:linear-gradient(0deg,red,blue);
```

- **repeating-linear-gradient()** 可以平铺的线性渐变。

```css
background: repeating-linear-gradient();
```

- **radial-gradient()** 径向渐变(放射性的效果)

  默认情况下径向渐变加以的形状来计算的

  radial-gradient(大小 at 位置，颜色 位置 ，颜色 位置 ，颜色 位置)

  - 正方形  --> 圆形
  - 长方形  --> 椭圆形

  我们可以指定渐变的位置

  - circle 圆
  - ellipse 椭圆
  - closest-side 近边
  - closest-corner 近角
  - farthest-side 远边
  - farthest-corner 远角

```css
background: radial-gradient(#e66465, #9198e5);
background: radial-gradient(closest-side, #3f87a6, #ebf8e1, #f69d3c);
background: radial-gradient(ellipse at top, #e66465, transparent),
            radial-gradient(ellipse at bottom, #4d9f0c, transparent);
```

# 8. 表格

- **rowspan** 行合并

- **colspan** 列合并

- **border-spacing**  指定边框之间的距离

- **border-collapse** 设置边框的合并    *设置了collapse，那么spacing就失效了*。

  如果表格中没有使用tbody而是直接使用tr,

  那么浏览器会自动创建一个tbody,并且将tr全都放到tbody中。所以tr不是table的子元素。

  默认情况下td中的元素是垂直居中的，可以通过vertical-align来设置

```html
<table>
    <tr>
        <td></td>
        <td></td>
        <td rowspan="2"></td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td colspan="2"></td>
    </tr>
</table>

<table>
   <thead>
       <tr>
           <th></th>
           <th></th>
           <th></th>
           <th></th>
           <th></th>
       </tr>
   </thead>
   <tbody>
       <tr>
           <td></td>
           <td></td>
           <td></td>
           <td></td>
           <td></td>
       </tr>
   </tbody>
   <tfoot>
       <tr>
           <td></td>
           <td></td>
           <td></td>
           <td></td>
       </tr>
   </tfoot>
</table>
```

> 可以通过display=table-cell;来使元素变成单元格，这样就可以使用vertical-align来居中了。
>
> ```css
> display: table-cell;
> vertical: middle;
> ```

# 9. 表单

- 在现实生活中表单用于提交数据
- 在网页中也可以使用表单，网页中的表单用于将本地的数据提交给远程的服务器。
- 使用form标签来创建一个表单

**form的属性**

- action 表单要提交的服务器的地址

- 文本框<input type="text" name="username"> 

  要提交数据到服务器，必须要为元素指定一个name值

- 密码框<input type="password" name="password"> 

- 单选按钮<input type="radio" name="hobby" value="1"> 

- 多选框<input type="checkbox" name="test" value="1"> 

- 下拉列表

```html
<form action="" autocomplete="false">
	<input type="text" name="username" autocomplete="false" readonly> 
	<input type="password" name="password"> 
	<input type="radio" name="hobby" value="1">
	<input type="checkbox" name="test" value="1">
	<select name="haha">
		<option value="1">选项一</option>
	</select>
	<input type="submit">
	<input type="reset">
	<input type="button" value="按钮">
	<input type="hidden">  
</form>
<!--
    readonly 只读  数据会提交
	disable 禁用 数据不会提交
	autofocus 自动获取焦点
-->
```

# Add Oil

- 可以通过display:none;来隐藏元素，也可以把高度设置为0px,overflow:hidden；来实现元素隐藏的效果，如果再加上一个**transition**属性

  ```css
  /*2秒完成高度变化  这样就有一个过渡的效果*/
  transition: height 2s;
  ```

- 三角形可以通过以下代码实现

  ```css
  border:10px solid transparent;
  width:0px;
  height:0px;
  border-top: none;
  border-bottom-color: red;
  ```

# 10. transition过渡

```css
/*通过过渡可以指定一个属性发生变化时的切换方式
通过过渡可以创建一些非常好的效果，提升用户体验*/
```

- **tansition-property** 指定要执行过渡的属性，多个属性间使用逗号隔开如果所有属性都需要过渡，可以用一个all关键字代替。大部分属性都支持过渡效果。过渡时必须是从一个有效值向另外一个有效值过渡。

  - ````css
    transition-duration: 2s;
    transition-property: margin-left,background-color;
    ````

- **transition-duration** 指定过渡效果的持续时间，1s = 1000ms

- **transition-timing-function** 过渡的时序函数

  可选值

  - ease  默认值   慢速开始，先加速，再减速

  - linear 匀速运动

  - ease-out 减速运动

  - ease-in-out 先加速 后减速

  - cubic-bezier (贝塞尔曲线)自己指定时序函数    [cubic-bezier]:https://cubic-bezier.com

  - steps() 分步执行过渡效果。可以设置两个值end 和 start，是在时间头执行不是在时间尾执行

    ```css
    steps(2s,end);
    steps(2s,start);
    ```

- **transition-delay** 过渡效果的延迟，等待一段时间后再执行过渡。

# 11. animation动画

​	动画和过渡类似，都可以实现一些动态的效果，不同的是过渡需要某个属性发生变化时才会触发，动画可以自动触发动态效果。

- **animation-iteration-count** 动画执行的次数，**整数次**或**infinite**无限次。

```css
animation-iteration-count:infinite;
```

- **animation-direction** 动画运行的方向，

  - **normal**  默认值 从from到to运行每次都是这样

  - **reverse** 从to到from运行  每次都是这样
  - **alternate**  （交替的意思） 从from到to,再从to回到from。往复执行，有原路返回意味。
- **alternate-reverse**  从to到from,再从from到to
  
- **animation-play-state** 动画的播放状态
  - **running** 默认值   动画执行
  - **paused** 动画暂停
- **animation-fill-mode** 动画的填充
  - **none** 默认值   回到to的位置
  - **forwardes** 动画执行完毕元素会停在动画结束的位置
  - **backwards**
  - **both**

```css
	.box1{
        width: 256px;
        height: 256px;
        margin: 0 auto;
        background-image: url("");
        animation: run 1s step(6) infinite;
    }

    @keyframes run {
        from{
            background-position: 0 0;
        }
        to{
            background-position: -1526px 0;
        }
    }
```

## 11.1 transform(改变形态)

​	变形就是指通过css来改变元素的形状或位置，变形不会影响到页面的布局。

- **translatex()** 沿着x轴方向平移

- **translatey() **沿着y轴方向平移

- **translatez()** 沿着z轴方向平移

  平移元素，百分比是相对于自身计算的。
  
  调整元素在z轴（z axis）的位置，正常情况就是调整元素和人眼之间的距离，距离越大，元素离人越近。
  
  z轴平移属于立体效果(近大远小)，默认情况下网页是不支持**perspective**(透视)的。
  
  如果要看到效果，必须设置网页的视距。
  
  ```css
  html{
      /*设置当前网页的视距为800px,人眼距离网页的距离*/
      perspective: 800px;
  }
  ```
  
  

> ```css
> position: asolute;
> top: 0;
> left: 0;
> bottom: 0;
> right: 0;
> margin: auto;
> 这种居中方式只适用于元素的大小确定时
> ```
>
> ```css
> left:50%;
> transform:translatex(-50%) translatey(-50%);
> 这种居中方式更加好
> ```
>

- **perspective()** 

- **rotate()** 通过旋转可以使元素沿着x  y 或 z 旋转指定的角度。

```css
是否显示元素的背面
backface-visibility: hidden;
backface-visibility: visible;
```

## 11.2 transform-style转换样式

```css
transform-style: flat;//指示元素的子元素位于元素本身的平面中。
transform-style: preserve-3d;//指示元素的子代应放置在3D空间中。
```

> **opacity**设置元素的不透明度，不透明度是元素后面的内容被隐藏的程度，与透明度相反。

## 11.3 scale()缩放

## 11.4 transform-origin 

​	设置转换的原点，默认情况下原点是**center**

# 12. less

​	less是一门css的预处理语言，less是一个css的增强版，通过less可以编写更少的代码实现更强大的样式。

> ​	下载插件Easy-Less

​	//less中的单行注释，这样的注释不会解析到css中

​	/*
​		less中的多行注释， 会被解析到css中

​	*/

| 编译前                                                       | 编译后                                                       |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| .box1{<br/>    background-color: red;<br/>    .box2{<br/>        background-color: #bfa;<br/>    }<br/>    .box3{<br/>        background-color: orange;<br/>    }<br/>} | .box1{<br/>   background-color: red;<br/> }<br/>.box1 .box2{<br/>    background-color: #bfa;<br/>}<br/>.box1 .box3{<br/>    background-color: orange;<br/>} |

> 变量，在变量中可以存储一个任意值
> 并且我们可以在需要时，任意的修改变量中的值
> 变量的语法， @变量名
>
> 使用变量时，如果是直接使用则以 @变量名 的形式使用即可
>
> 变量发生重名时，会优先使用比较近的变量

| 编译前                                                       | 编译后                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| @a: 200px;<br/>@b: red;<br/>@c: box6;<br/>.box5{<br/>    width: @a;<br/>    color: @b;<br/>}<br/>.@c{<br/>    background-image: url("@{c}/1.png");<br/>} | .box5{<br/>    width:  200px;<br/>    color: red;<br/>}<br/>.box6{<br/>    background-image: url("box6/1.png");<br/>} |

> &还可以表示外层元素

| 编译前                                                       | 编译后                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| .box1{<br/>    &:hover{<br/>        color: orange;<br/>    }<br/>} | .box1 {<br/>  background-color: red;<br/>}<br/>.box1:hover {<br/>  background-color: blue;<br/>} |

> extend() 对当前选择器扩展指定选择器的样式(选择器分组)

| 编译前                                                       | 编译后                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| .p1{<br/>width: 200px;<br/>height: 200px;<br/>}<br>.p2:extend(.p1){<br/>color: red;<br>} | .p1{<br/>width:200px;<br/>height:200px;<br/>}<br/>.p2{<br>width:200px;<br/>height:200px;<br/>color:red;<br/>} |

> 直接对指定的样式进行引用，这里就相当于将p1的样式直接复制了一下，引用的时候，括号可以省略。

| 编译前                                                       | 编译后                               |
| ------------------------------------------------------------ | ------------------------------------ |
| .p1{<br/>width:10px;<br>height:10px;<br>}<br>.p3{<br>.p1();<br>} | .p3{<br>width:10px;<br>height:10px;} |

> 使用类选择器可以在选择器后边添加一个括号，这时我们实际创建了一个mixins，.p()不会在css中编译。

```less
.p(){
    width: 10px;
    height: 10px;
}

.p1{
    .p;
}
```

> 混合函数的使用

```less
.test(@w:100px,@h:200px,@bg-color:red){
    width: @w;
    height: @h;
    background-color: @bg-color;
}

div{
    .test(200px);
}
```

> import用来将less文件引入，这样可以进行模块化

```less
@import "syntax.less";
```

> less在浏览器中显示对应的行数
>
> "less.compile": {
>       "compress":  false,  *// true => remove surplus whitespace*
>       "sourceMap": true,  *// true => generate source maps (.css.map files)*
>       "out":       true, *// false => DON'T output .css files (overridable per-file, see below)*
>  }
>
> 在vs code 的设置中，找到扩展下面的Easy LESS configuration进行编程。

# 13.flex弹性盒、伸缩盒

​	是css中的又一种布局的手段，它主要用来代替浮动来完成页面布局。

​	flex可以使元素具有弹性，让元素可以跟随页面的大小改变而改变。

​	**弹性容器**：要使用弹性盒，必须先将一个元素设置为弹性容器。我们通过display 来设置弹性容器

```css
display: flex;//设置为块级弹性容器。
display: inline-flex;//设置为行内的弹性容器。
display: -webkit-flex; //webkit内核的浏览器，必须加上-webkit前缀。
```

​	![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png)

> 注意：元素设置为了flex布局以后，子元素的 **float**、**clear**、**vertical-align**属性将失效。



**弹性元素**：弹性容器（flex container）的子元素是弹性元素(弹性项，flex item)，一个元素可以同时是弹性容器和弹性元素。

​	**flex-direction** 指定窗口中弹性元素的排列方式

可选值：

- row 默认值，弹性元素在容器中水平排列(从左向右)。
- row-reverse 弹性元素在容器中反射水平排列(从右向左)
- column   弹性元素纵向排列(自上而下)
- column-reverse 弹性元素纵向排列(自下而上)



​	**flex-wrap**	设置将弹性项目强制到一行还是可以换行。如果允许换行，它将设置线条堆叠的方向。

可选值：

- nowrap  默认值   单行布局(不换行)，可能导致the flex container 溢出，（不换行）
- wrap  会换行
- wrap-reverse  元素沿着辅轴相反方向换行

​	**flex-flow**  是flex-direction和flex-wrap属性的简写属性。默认值为：row nowrap;

​	**flex-grow** 设置弹性增长因子(**the flex grow factor**)，如果所有兄弟都有相同的增长因子，那么就等额分配，否则根据不同的弹性增长因子比率进行分配。

> in case both `flex-basis` (other than `auto`) and `width` (or `height` in case of `flex-direction: column`) are set for an element, `flex-basis` has priority.

​	**flex-basis**  设默认值为auto，设置为negative value无效，置弹性元素的初始主要尺寸，除非设置了box-sizing, 否则它将设置content box 的大小。

​	**flex-shrink**  设置收缩因子(**shrink factor**)

​	**justify-content** 如何分配**主轴**上的空间(主轴上的元素如何排列)

可选值：

- flex-start 元素沿着主轴左边排列
- flex-end 元素沿着主轴右边排列
- center 元素沿着主轴居中排列
- space-around 空白分布到元素两测
- space-evenly 空白分布到元素的单侧
- space-between 空白均匀分布到元素间



​	**align-items** 属性定义项目在**辅轴**上如何对齐

- flex-start  辅轴的起点对齐
- flex-end 辅轴的终点对齐
- center 辅轴的中点对齐
- baseline 项目的第一行文字的基线对齐
- stretch 默认值：如果项目未设置高度或设为auto，将占满整个窗口的高度。

![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png)

**align-content**  定义了多根轴线的对齐方式，如果项目只胡一根轴线，该属性不起作用。

- flex-start  辅轴起点
- flex-end 辅轴终点
- center 辅轴中点
- space-between 辅轴两端对齐，轴线之间的间隔平均分布
- space-around 每根轴线两侧的间隔都相等，所以，轴线之间的间隔比轴线与边框的间隔大一些。
- stretch 默认值，轴线占满整个辅轴。

![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png)

## 13.1 flex item 弹性项目

- order 属性定义项目的排列，数值越小，排列越靠前，默认为0。

```css
.item{
    order: <integer>; /* default 0 */
}
```

- **flex-grow** 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间(如果有的话)。如果一个项目的flex-grow属性为2，其它项目都为1，则前者占据的剩余空间将比其他项多一倍。  

```css
.item{
    flex-grow: <number>; /* default 0 /
}
```

- **flex-shrink** 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目缩小。如果所有item的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。设置negative value无效。

```css
.item{
    flex-shrink: <number>; /* default 1 */
}
```

- **flex-basis** 属性定义在分配多余空间之前，项目占据的主轴空间(main size)，浏览器根据这个属性，计算主轴是否有多余空间，它的默认值为auto，即项目的本来大小。它可以设为跟width 或 height 属性一新的值(比如350px),项目将占据固定空间。
- **flex** 属性是 **flex-grow** 、 **flex-shrink** 、 **flex-basis** 的简写，默认值为  0  1  auto。后两个属性可选。可用快捷值如下：
  - auto  （0 1 auto）
  - none    (0 0 auto)
- **align-self** 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性，默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch.

```css
.item{
    align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
```

#  14. JavaScript

```javascript
NaN === NaN //false
//唯一能判断NaN的方法是使用isNaN()函数；
//启用严格模式的方法是在JavaScript代码的第一行写上：
"use strict";
```

- NaN === NaN //false
- 唯一能判断NaN的方法是使用isNaN()函数；
- //启用严格模式的方法是在JavaScript代码的第一行写上：
  "use strict";

## 14.1 数组

- **slice()**，截取数组的部分元素，然后返回一个新的数组。

  slice(param1param2; //[param1,param2)

  slice(param1); //从

  ```javascript
  slice(param1,param2; //截取[param1,param2)，可以传负整数
  slice(param1); //截取从param1到数组最后一个元素
  slice(); //复制出来了一个新的数组，与原数据内容完全一样，但是内存地址不一样。
  ```

- **splice()**方法可用于向数组添加新项

  第一个参数定义了应添加新元素的位置(拼接)

  第二个参数定义应删除多少个元素

  其余参数定义要添加的新元素

  ```javascript
  var arr = ["my","you","her","she","they"];
  var result = arr.splice(1,2,"abc","cde"); 
  // result = ["you","her"]，此时的arr已经被改变了
  //从索引为1的元素开始，删除二个元素，并在此处添加abc和cde两个元素,并返回删除的元素。改变了原数组
  ```

- **push()**向数组最后面push元素。并返回数据的length

- **pop()**不带任何参数，弹出数组的最后一个元素，并返回这个元素的值。

- **shift()** 删除数组中的第一个元素，并返回这个元素。

- **unshift()**向数组中0号索引位添加一个或多个元素，并返回数组的length。

- **concat()**拼接两个数组，并返回一个新的数组。

  ```javascript
  var myGirls = ["Emma", "Isabella"];
  var myBoys = ["Jacob", "Michael", "Ethan"];
  var my = ["my"];
  //这个是拼接两个数组
  var myChildren = myGirls.concat(myBoys);
  //这个是拼接三个数组
  var three = myGirls.concat(myBoys,my);
  
  ```

- **toString()**返回数组字符串

- **join()**可以指定分隔符

  ```javascript
  var myGirls = ["Emma", "Isabella"];
  var result = myGirls.join("*");
  //result = "Emma*Isabella"
  ```

- **sort()** 可以对当前数组进行排序，它会直接修改当前数组的元素位置

- **isArray()**判断对象是否是一个数组
- **includes()**判断一个数组是否包含一个指定的值
- **map()**通过指定函数处理数组的每个元素，并返回处理后的数组。

```javascirpt
function pow(x) {
    return x * x;
}
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var results = arr.map(pow);//让每个元素都传给pow()函数，并返回最终结果
console.log(results); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
```

- **reduce()**数组的 `reduce()` 把一个函数作用在这个数组的 `[x1, x2, x3…]` 上，这个函数必须接收两个参数。`reduce()` 把结果继续和序列的下一个元素做累积计算，其效果就是：

```javascript
[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)
```

比方说对一个数组求和，就可以用 `reduce()` 实现：

```javacript
var arr = [1,2,3,4,5];
function add(x,y) {
	return x + y;
}
var result = arr.reduce(add);
```

语法**reduce(callback,initialValue);**

```javascript
callback （执行数组中每个值的函数，包含四个参数）

    1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））
    2、currentValue （数组中当前被处理的元素）
    3、index （当前元素在数组中的索引）
    4、array （调用 reduce 的数组）

initialValue （作为第一次调用 callback 的第一个参数。）
```

> **如果没有提供initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供initialValue，从索引0开始。如果这个数组是个空的，在不给initialValue的情况下会报错，给了initalValue就不会报错。**

```javascript
var  arr = [1, 2, 3, 4];
var sum = arr.reduce((x,y)=>x+y);
var mul = arr.reduce((x,y)=>x*y);
console.log( sum ); //求和，10
console.log( mul ); //求乘积，24
```

例1：计算数组中每个元素出现的次数，**前方高能**

```javascript
let names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];

let nameNum = names.reduce((pre,cur)=>{
  if(cur in pre){
    pre[cur]++;//如果pre里面有cur，那么cur的值肯定是一个整数，那么进行++就完全可以
  }else{
    pre[cur] = 1 //如果pre里面没有cur,那么给per中添加一个cur属性，并给一个初值1。
  }
  return pre
},{})
console.log(nameNum); //{Alice: 2, Bob: 1, Tiff: 1, Bruce: 1}
/*
	上面reduce()的第二个参数给了一个没有内容的空对象，对么reduce()就会从0索引开始进行遍历。首先pre成为{}，cur成为'Alice'
*/
```

例二：数组去重

```javascript
let arr = [1,2,3,3,2,4,3,5,6,5,7];
let result = arr.reduce((pre,cur)=>{
    if(!pre.includes(cur)){//如果pre这个数组中不包含cur,那么就将cur添加到pre中。
      return pre.concat(cur)
    }else{
      return pre
    }
},[]);
console.log(result);
```

- **filter()**检测数值元素，并返回符合条件所有元素的数组

```javascript
var arr = [1,2,2,3,4,5,6,7,8,7];
var result = arr.filter(item => {
    return item > 5
});
console.log(result);
```



## 14.2 对象

JavaScript 的对象是一种无序的集合数据类型，它由若干键值对组成。

访问对象的属性通过 `.` 操作符完成，但这要求属性名必须是一个**有效的变量名**。如果属性名包含特殊字符，就必须用引号括起来：

```javascript
var person = {
  name : "Mitsuha",
  age : 10
};
person.sex = "男"；
delete person.sex;
delete person["sex"];//两个效果是一样的，如果删除一个没有属性，也不会报错，
"name" in person;
//检查name属性是否在person中。这个in,能检查出继承来的属性。
person.hasOwnProperty("name");//检查是否是自身的属性。
```

## 14.3 变量作用域与解构赋值

- 变量提升：函数声明和变量声明总是会被解释器悄悄地被"提升"到方法体的最顶部。只提升声明，不提升初始化。

```javascript
x = 5; // 变量 x 设置为 5

elem = document.getElementById("demo"); // 查找元素
elem.innerHTML = x;                     // 在元素中显示 x

var x; // 声明 x
```

```javascript
var x; // 声明 x
x = 5; // 变量 x 设置为 5

elem = document.getElementById("demo"); // 查找元素
elem.innerHTML = x;                     // 在元素中显示 x
```

上面两段代码有相同的效果，**但是在in strict模式下是不允许使用未声明的变量的。**

- 全局作用域，不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript 默认有一个全局对象 `window`，全局作用域的变量实际上被绑定到 `window` 的一个属性。

- 局部作用域，由于 JavaScript 变量作用域实际上是函数内部，在 `for` 循环等语句块中无法定义具有局部作用域的变量：

  ```javascript
  "use strict";
  function foo() {
      for (var i = 0; i < 100; i++) {
          //
      }
      i += 100;//在for循环外现在仍可以使用i，故引入了let关键字来解决块级作用域
  }
  ```


## 14.4 解构赋值

```
var [x, y, z] = ["hello", "JavaScript", "ES6"];
// x、y、z 分别被赋值为数组对应元素：
console.log("x = " + x + ", y = " + y + ", z = " + z); // x = hello, y = JavaScript, z = ES6
```

```javascript
let [x, [y, [z]]] = ["hello", ["JavaScript", ["ES6"]]];
x; // "hello"
y; // "JavaScript"
z; // "ES6"
```

```javascript
let [, , z] = ["hello", "JavaScript", "ES6"]; // 忽略前两个元素，只对 z 赋值第三个元素
z; // "ES6"
```

```javacript
var person = {
    name: "小明",
    age: 20,
    gender: "male",
    passport: "G-12345678",
    school: "No.4 middle school"
};
var {
    name,
    age,
    passport
} = person;
// name、age、passport 分别被赋值为对应属性：
console.log("name = " + name + ", age = " + age + ", passport = " + passport); // name = 小明, age = 20, passport = "G-12345678"
```

```javascript
var person = {
    name: "小明",
    age: 20,
    gender: "male",
    passport: "G-12345678",
    school: "No.4 middle school",
    address: {
        city: "Beijing",
        street: "No.1 Road",
        zipcode: "100001"
    }
};
var {
    name,
    address: {
        city,
        zip
    }
} = person;
name; // "小明"
city; // "Beijing"
zip; // undefined。因为属性名是 zipcode 而不是 zip
// 注意：address 不是变量，而是为了让 city 和 zip 获得嵌套的 address 对象的属性：
address; // Uncaught ReferenceError: address is not defined
```

```javascript
var person = {
    name: "小明",
    age: 20,
    gender: "male",
    passport: "G-12345678",
    school: "No.4 middle school"
};

// 把 passport 属性赋值给变量 id：
let {
    name,
    passport: id
} = person;
name;   // "小明"
id;     // "G-12345678"
// 注意：passport 不是变量，而是为了让变量 id 获得 passport 属性：
passport; // Uncaught ReferenceError: passport is not defined
```

```javascript
var person = {
    name: "小明",
    age: 20,
    gender: "male",
    passport: "G-12345678"
};

// 如果 person 对象没有 single 属性，默认赋值为 true：
var {
    name,
    single = true
} = person;
name;   // "小明"
single; // true
```

```javascript
// 声明变量:
var x, y;
// 解构赋值:
{
    x,
    y
} = {
    name: "小明",
    x: 100,
    y: 200
};
// 语法错误：Uncaught SyntaxError: Unexpected token =
```

快速获取当前页面的域名和路径

```javascript
var {
    hostname: domain,
	pathname: path
} = location;
```

## 14.5 apply()和call()方法

要指定函数的 `this` 指向哪个对象，可以用函数本身的 `apply()` 方法。它接收两个参数，第一个参数就是需要绑定的 `this` 变量；第二个参数是数组，表示函数本身的参数。

apply()和call()方法的唯一区别是apply()第二个参数是数组，call()方法的是把参数按顺序传入。

对普通函数调用，通常把 `this` 绑定为 `null`。

apply()还可以当装饰器使用。

```javascript
//让window中的parseInt重新指向我们自定义的函数
var count = 0;
var oldParseInt = parseInt; // 保存原函数
window.parseInt = function () {
    count += 1;
    return oldParseInt.apply(null, arguments); // 调用原函数
};

// 测试：
parseInt("10");
parseInt("20");
parseInt("30");
console.log("count = " + count); // 3
```

## 14.6 高阶函数

```javascript
function add(x, y, f) {
    return f(x) + f(y);
}
var x = add(-5, 6, Math.abs);
console.log(x); // 11
```

## 14.7 map()

```javascript

```

# 总结

> 立即执行函数只会执行一次，函数执行完，立即被调用
>
> （function(a,b){
>
> ​	console.log("a = " + a);
>
> ​	console.log("b = " + b);
>
> }）

> 对象的属性值可以是任何的数据类型，也可以是个函数
>
> Obj.sayName = function() {
>
> ​	console.log("name");
>
> };
>
> obj.sayName();//调函数
>
> //**以函数调用,this永远指向的是window。**
>
> //**以方法调用，this就是调用方法的那个对象**
>
> function Persion() {
>
> ​	var person = new Person();
>
> }
>
> 对象   instanceof Person;//判断这个对象是否是Person

## prototype原型

我们所创建的每一个函数，解析器都会向函数中添加一个prototype属性，这个属性对应着一个对象，这个对象就是我们所谓的原型对象。如果函数作为普通函数调用prototype没有任何作用。

当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性。指向该构造函数的原型对象，我们可以通过__ proto__来访问该发展。原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。

> **使用in检查对象是否含有某个属性时，如果对象中没有，但是prototype中有，则会返回true,可以使用对象的hasOwnProperty()来检查对象自身是否含有该属性**

## Garbage Collection(GC)垃圾回收

我们只需要做的只是要将不再使用的对象设置null即可

在调用函数时，浏览器每次都会传递进两个隐含的参数

- 函数的上下文对象  **this**
- 封装实参的对象 arguments
  - arguments是一个类数组对象，它可以通过索引来操作数据，也可以获取长度
  - 在调用函数时，我们所传递的实参都会在arguments中保存
  - arguments.length可以用来获取实参的长度
  - 我们即使不定义形参，也可以通过arguments来使用参数，只不过比较麻烦。arguments[0]表示第一个参数，
  - 它里面有一个属性叫做callee，这个属性对应一个函数对象，就是当前正在指向的函数的对象。



**document.createElement()**可以用于创建一个元素节点对象，它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回。



- clientWidth

- clientHeight

  这两个属性可以获取元素的可见宽度和高度。这些属性都是不带px的，返回都是一个数字，可以直接进行计算，会获取元素宽度和高度，包括内容区和内边距。这些属性都是只读的，不能修改

- offsetWidth

- offsetHeight 

  获取元素的整个的宽度和高度，包括内容区、内边距和边距
我添加了几个字来测试
